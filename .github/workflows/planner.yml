name: DarkForge Planner

on:
  workflow_call:
    inputs:
      epic_number:
        required: true
        type: string
  workflow_dispatch:
    inputs:
      epic_number:
        description: "Epic issue number"
        required: true
        type: string
  issues:
    types: [opened, labeled]

permissions:
  contents: write
  issues: write
  pull-requests: read

concurrency:
  group: darkforge-planner-${{ github.repository }}-${{ inputs.epic_number || github.event.issue.number || github.run_id }}
  cancel-in-progress: false

jobs:
  decompose:
    if: ${{ github.event_name != 'issues' || contains(github.event.issue.title, '[EPIC]') || contains(join(github.event.issue.labels.*.name, ','), 'df:intake') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Resolve epic number
        id: epic
        run: |
          EPIC="${{ inputs.epic_number || github.event.inputs.epic_number || github.event.issue.number }}"
          echo "number=$EPIC" >> "$GITHUB_OUTPUT"

      - name: Ensure DarkForge labels exist
        uses: actions/github-script@v7
        with:
          script: |
            const labels = [
              {name: 'df:blocked', color: 'B60205', description: 'Task blocked by dependencies'},
              {name: 'df:ready', color: '0E8A16', description: 'Task ready for execution'},
              {name: 'df:task', color: '1D76DB', description: 'DarkForge generated task'},
              {name: 'df:epic-child', color: '5319E7', description: 'Generated from epic decomposition'}
            ];
            for (const label of labels) {
              try {
                await github.rest.issues.getLabel({ owner: context.repo.owner, repo: context.repo.repo, name: label.name });
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({ owner: context.repo.owner, repo: context.repo.repo, ...label });
                } else {
                  throw e;
                }
              }
            }

      - name: Fetch epic payload
        id: epic_payload
        uses: actions/github-script@v7
        with:
          script: |
            const epicNumber = Number('${{ steps.epic.outputs.number }}');
            const { data: epic } = await github.rest.issues.get({ owner: context.repo.owner, repo: context.repo.repo, issue_number: epicNumber });
            const slug = epic.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '').slice(0, 48) || `epic-${epicNumber}`;
            const payload = { number: epicNumber, title: epic.title, body: epic.body || '', slug };
            core.setOutput('slug', slug);
            core.setOutput('jsonPath', `darkfactory/tasks/${slug}.epic.json`);
            core.setOutput('planPath', `darkfactory/tasks/${slug}.plan.json`);
            core.setOutput('graphPath', `darkfactory/tasks/${slug}.json`);
            require('fs').mkdirSync('darkfactory/tasks', { recursive: true });
            require('fs').writeFileSync(`darkfactory/tasks/${slug}.epic.json`, JSON.stringify(payload, null, 2));

      - name: Generate PM/TPM/Architect plan (LLM-backed)
        run: |
          node darkfactory/scripts/llm-plan.js "${{ steps.epic.outputs.number }}" "${{ steps.epic_payload.outputs.jsonPath }}" "${{ steps.epic_payload.outputs.planPath }}"

      - name: Build task graph from generated plan
        id: graph
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const epic = JSON.parse(fs.readFileSync('${{ steps.epic_payload.outputs.jsonPath }}','utf8'));
          const plan = JSON.parse(fs.readFileSync('${{ steps.epic_payload.outputs.planPath }}','utf8'));
          const tasks = (plan.architect?.tasks || []).map((t, idx) => ({
            id: t.id || `E${epic.number}-T${idx+1}`,
            title: t.title,
            owner_role: t.owner_role || 'engineer',
            status: (t.depends_on && t.depends_on.length) ? 'blocked' : 'ready',
            depends_on: t.depends_on || [],
            parallelizable: !!t.parallelizable,
            acceptance: t.acceptance || []
          }));
          const graph = { epic_issue: epic.number, epic_title: epic.title, epic_slug: epic.slug, satisfaction: 0, tasks, pm: plan.pm || {}, tpm: plan.tpm || {} };
          fs.writeFileSync('${{ steps.epic_payload.outputs.graphPath }}', JSON.stringify(graph, null, 2));
          NODE

      - name: Create/sync child issues from task graph
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const graph = JSON.parse(fs.readFileSync('${{ steps.epic_payload.outputs.graphPath }}', 'utf8'));
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const listAll = async () => {
              const all = [];
              let page = 1;
              while (true) {
                const { data } = await github.rest.issues.listForRepo({ owner, repo, state: 'all', per_page: 100, page });
                if (!data.length) break;
                all.push(...data.filter(i => !i.pull_request));
                page++;
              }
              return all;
            };

            const allIssues = await listAll();

            for (const task of graph.tasks) {
              const marker = `DarkForge-Task-ID: ${task.id}`;
              const body = [
                `Parent Epic: #${graph.epic_issue}`,
                marker,
                `Owner Role: ${task.owner_role}`,
                `Parallelizable: ${task.parallelizable}`,
                `Depends-On: ${task.depends_on.length ? task.depends_on.join(', ') : 'none'}`,
                '',
                '## Task',
                task.title,
                '',
                '## Acceptance Criteria',
                ...task.acceptance.map(a => `- ${a}`)
              ].join('\n');

              const title = `[TASK] ${task.title}`;
              const existing = allIssues.find(i => (i.body || '').includes(marker));

              const labels = ['df:task', 'df:epic-child', task.status === 'ready' ? 'df:ready' : 'df:blocked'];

              if (existing) {
                await github.rest.issues.update({ owner, repo, issue_number: existing.number, title, body });
                await github.rest.issues.setLabels({ owner, repo, issue_number: existing.number, labels });
              } else {
                await github.rest.issues.create({ owner, repo, title, body, labels });
              }
            }

      - name: Post planning summary to epic
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const graph = JSON.parse(fs.readFileSync('${{ steps.epic_payload.outputs.graphPath }}', 'utf8'));
            const pmSummary = graph.pm?.summary || 'PM summary generated.';
            const tpmRec = graph.tpm?.recommendation || 'TPM recommendation generated.';
            const body = [
              '## DarkForge Planner Output',
              '',
              `- PM: ${pmSummary}`,
              `- TPM Recommendation: ${tpmRec}`,
              `- Tasks Generated: ${graph.tasks.length}`,
              '',
              `Task graph file: \`${{ steps.epic_payload.outputs.graphPath }}\``
            ].join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: Number('${{ steps.epic.outputs.number }}'),
              body
            });

      - name: Commit planner artifacts
        run: |
          git config user.name "darkforge-bot"
          git config user.email "darkforge-bot@users.noreply.github.com"
          git add darkfactory/tasks/*.json
          git diff --cached --quiet || git commit -m "feat(planner): decompose epic #${{ steps.epic.outputs.number }} into task graph"
          git push || true
